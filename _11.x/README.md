# Глава 11 – Функции

___

## Вопрос 1

Напишите прототипы функций для следующих случаев. При необходимости используйте `const`.

a) Функция с именем `max()`, которая принимает два значения `double` и возвращает большее из двух.

b) Функция под названием `swap()`, которая меняет местами два числа int.

c) Функция с именем `getLargestElement()`, которая принимает динамически выделенный массив чисел `int` и возвращает наибольшее число таким образом, что вызывающий может изменить значение возвращаемого элемента (не забудьте параметр длины).

__Ответ:__

a) `double max(const double a, const double b);`

b) `void swap(int& a, int& b);`

c) `int& getLargestElement(int* arr, int length);`
___

## Вопрос 2

Что не так с этими фрагментами кода?

a)

```cpp
int& doSomething()
{
    int array[]{ 1, 2, 3, 4, 5 };
    return array[3];
}
```

b)

```cpp
int sumTo(int value)
{
    return value + sumTo(value - 1);
}
```

c)

```cpp
float divide(float x, float y)
{
    return x / y;
}
 
double divide(float x, float y)
{
    return x / y;
}
```

d)

```cpp
#include <iostream>
 
int main()
{
    int array[100000000]{};
 
    for (auto x: array)
        std::cout << x << ' ';
 
    std::cout << '\n';
 
    return 0;
}
```

e)

```cpp
#include <iostream>
 
int main(int argc, char *argv[])
{
    int age{ argv[1] };
    std::cout << "The user's age is " << age << '\n';
 
    return 0;
}
```

__Ответ:__

a) Массив уничтожится в конце функции. Возвращённая ссылка будет вести на уже не существующий элемент массива

b) Рекурсивная функция без условия остановки. Она будет выполняться до тех пор, пока не вызовет переполнение стека

c) Компилятор считает функции одинаковыми, так как тип возвращаемых данных не хватает для перегрузки функции

d) Массив слишком большой для размещения в стеке. Его стоит выделить динамически

e) Нет проверки на существование `argv[1]`. `argv` — является строковым аргументом, её надо явно преобразовать в `int`.
___

## Вопрос 3

Лучший алгоритм определения наличия значения в отсортированном массиве называется двоичным (бинарным) поиском.

Бинарный поиск работает следующим образом:

* Найти центральный элемент массива (если в массиве четное количество элементов, округлить в меньшую сторону).
* Если центральный элемент больше целевого элемента, отбросить верхнюю половину массива (или выполнить рекурсию для нижней половины)
* Если центральный элемент меньше целевого элемента, отбросить нижнюю половину массива (или выполнить рекурсию для верхней половины).
* Если центральный элемент равен целевому элементу, вернуть индекс центрального элемента.
* Если отбрасывается весь массив, не найдя целевой элемент, вернуть контрольное значение, которое представляет «не найден» (в этом случае мы будем использовать -1, поскольку это недопустимый индекс массива).

Поскольку с каждой итерацией мы можем отбрасывать половину массива, этот алгоритм очень быстр. Даже с массивом из миллиона элементов требуется не более 20 итераций, чтобы определить, присутствует ли значение в массиве или нет! Однако он работает только с отсортированными массивами.

Изменение массива (например, отбрасывание половины элементов в массиве) стоит дорого, поэтому обычно мы не модифицируем массив. Вместо этого мы используем два целых числа (min и max) для хранения индексов минимального и максимального элементов массива, который мы хотим исследовать.

Давайте посмотрим на пример того, как работает этот алгоритм, на массиве {3, 6, 7, 9, 12, 15, 18, 21, 24} и целевом значении 7. Сначала min = 0, max = 8, потому что мы ищем во всем массив (длина массива 9, поэтому индекс последнего элемента равен 8).

* Шаг 1) Вычисляем среднюю точку min (0) и max (8), которая равна 4. Элемент № 4 имеет значение 12, которое больше нашего целевого значения. Поскольку массив отсортирован, мы знаем, что все элементы с индексом, равным или превышающим среднюю точку (4), должны быть слишком большими. Поэтому мы оставляем min неизменным и устанавливаем max равным 3.
* Шаг 2) Мы вычисляем среднюю точку min (0) и max (3), которая равна 1. Элемент № 1 имеет значение 6, которое меньше нашего целевого значения. Поскольку массив отсортирован, мы знаем, что все элементы с индексом, равным или меньшим средней точки (1), должны быть слишком маленькими. Поэтому мы устанавливаем min на 2, а max не меняем.
* Шаг 3) Мы вычисляем среднюю точку min (2) и max (3), которая равна 2. Элемент № 2 имеет значение 7, которое является нашим целевым значением. Итак, возвращаем 2.

Дан следующий код:

```cpp
#include <iostream>
#include <iterator>
 
// array - это массив для поиска.
// target - это значение, которое мы пытаемся определить, есть оно или нет.
// min - это индекс нижней границы массива, в котором мы ищем.
// max - это индекс верхней границы массива, в котором мы ищем.
// binarySearch() должна возвращать индекс целевого элемента, если target найден, иначе -1
int binarySearch(const int *array, int target, int min, int max)
{
 
}
 
int main()
{
    constexpr int array[]{ 3, 6, 8, 12, 14, 17, 20, 21, 26, 32, 36, 37, 42, 44, 48 };
 
    // Мы собираемся протестировать набор значений, чтобы увидеть,
    // дают ли они ожидаемые результаты
    constexpr int numTestValues{ 9 };
    // Вот тестовые значения
    constexpr int testValues[numTestValues]{ 0, 3, 12, 13, 22, 26, 43, 44, 49 };
    // А вот ожидаемые результаты для каждого значения
    int expectedValues[numTestValues]{ -1, 0, 3, -1, -1, 8, -1, 13, -1 };
 
    // Перебираем все тестовые значения
    for (int count{ 0 }; count < numTestValues; ++count)
    {
        // Смотрим, есть ли наше тестовое значение в массиве
        int index{ binarySearch(array, testValues[count], 0, static_cast<int>(std::size(array)) - 1) };
        // Если результат соответствует ожидаемому, тогда отлично!
        if (index == expectedValues[count])
             std::cout << "test value " << testValues[count] << " passed!\n";
        else // иначе наша функция binarySearch() не работает
             std::cout << "test value " << testValues[count] << " failed.  There's something wrong with your code!\n";
    }
 
    return 0;
}
```

a) Напишите итеративную версию функции binarySearch.
Подсказка: можно с уверенностью сказать, что целевой элемент не существует, если минимальный индекс больше максимального.

b) Напишите рекурсивную версию функции binarySearch.

__Ответ:__

a) [ответ](Вопрос_3/Вопрос_3.cpp)

b) [ответ](Вопрос_3b/Вопрос_3b.cpp)
