# Глава 13 – Перегрузка операторов  

___

## Вопрос 1

Предполагая, что Point является классом, а точка point является экземпляром этого класса, в какой форме следует использовать перегрузку для следующих операторов (обычная/дружественная функция или функция-член)?

a) `point + point`
b) `-point`
c) `std::cout << point`
d) `point = 5`

__Ответ:__

a) Обычная/дружественная функция

b) Функция-член

c) Обычная/дружественная функция

d) Функция-член
___

## Вопрос 2

Напишите класс с именем Average, который будет отслеживать среднее значение всех переданных ему целых чисел. Используйте два члена: первый должен иметь тип std::int_least32_t и использоваться для отслеживания суммы всех чисел, которые вы видели на данный момент. Второй должен иметь тип std::int_least8_t и использоваться для отслеживания того, сколько чисел вы уже видели. Вы можете разделить их, чтобы найти среднее значение.

2a) Напишите все функции, необходимые для запуска следующей программы:

```cpp
int main()
{
    Average avg{};
    
    avg += 4;
    std::cout << avg << '\n'; // 4 / 1 = 4
    
    avg += 8;
    std::cout << avg << '\n'; // (4 + 8) / 2 = 6
 
    avg += 24;
    std::cout << avg << '\n'; // (4 + 8 + 24) / 3 = 12
 
    avg += -10;
    std::cout << avg << '\n'; // (4 + 8 + 24 - 10) / 4 = 6.5
 
    (avg += 6) += 10; // два вызова объединены в цепочку
    std::cout << avg << '\n'; // (4 + 8 + 24 - 10 + 6 + 10) / 6 = 7
 
    Average copy{ avg };
    std::cout << copy << '\n';
 
    return 0;
}
```

и выдается следующий результат:

```text
4
6
12
6.5
7
7
```

Подсказка: помните, что 8-битные целые числа обычно являются символами char, поэтому std::cout обрабатывает их соответственно.

2b) Нужен ли этому классу явные конструктор копирования и оператор присваивания?

__Ответ:__

a) [Ответ](Вопрос_2/Вопрос_2.cpp)

b) Нет
___

## Вопрос 3

Напишите свой собственный класс целочисленного массива с именем IntArray с нуля (не используйте std::array или std::vector). Пользователи должны передавать размер массива при его создании, и массив должен размещаться динамически. Используйте инструкции assert для защиты от недопустимых данных. Создайте любые конструкторы и перегруженные операторы, необходимые для правильной работы следующей программы:

```cpp
#include <iostream>
 
IntArray fillArray()
{
    IntArray a(5);
 
    a[0] = 5;
    a[1] = 8;
    a[2] = 2;
    a[3] = 3;
    a[4] = 6;
 
    return a;
}
 
int main()
{
    IntArray a{ fillArray() };
    std::cout << a << '\n';
 
    auto &ref{ a }; // используем эту ссылку, чтобы избежать
                    // ошибок компиляции, связанных с самоприсваиванием
    a = ref;
 
    IntArray b(1);
    b = a;
 
    std::cout << b << '\n';
 
    return 0;
}
```

Эта программа должна напечатать:

```text
5 8 2 3 6
5 8 2 3 6
```

__Ответ:__

[Вопрос_3](Вопрос_3/Вопрос_3.cpp)
___

## Вопрос 4

Дополнительный вопрос: немного сложнее. Число с плавающей запятой – это число с дробной частью, где количество цифр после запятой может быть переменным. Число с фиксированной запятой – это число с дробной частью, где количество цифр в дробной части фиксировано.

В этом тесте мы собираемся написать класс для реализации числа с фиксированной запятой с двумя цифрами в дробной части (например, 12.34, 3.00 или 1278.99). Предположим, что диапазон значений класса должен быть от -32768.99 до 32767.99, что дробная часть должен содержать любые две цифры, что нам не нужны ошибки точности, и что мы хотим сэкономить место.

4a) Какой тип переменных-членов, по вашему мнению, мы должны использовать для реализации нашего числа с фиксированной запятой с двумя цифрами после запятой? (Убедитесь, что вы прочитали ответ, прежде чем переходить к следующим вопросам)

4b) Напишите класс с именем FixedPoint2, реализующий рекомендованное решение из предыдущего вопроса. Если одна (или обе) из частей числа (целая или дробная) отрицательна, число следует рассматривать как отрицательное. Предоставьте перегруженные операторы и конструкторы, необходимые для запуска следующей программы:

```cpp
int main()
{
    FixedPoint2 a{ 34, 56 };
    std::cout << a << '\n';
 
    FixedPoint2 b{ -2, 8 };
    std::cout << b << '\n';
 
    FixedPoint2 c{ 2, -8 };
    std::cout << c << '\n';
 
    FixedPoint2 d{ -2, -8 };
    std::cout << d << '\n';
 
    FixedPoint2 e{ 0, -5 };
    std::cout << e << '\n';
 
    std::cout << static_cast<double>(e) << '\n';
 
    return 0;
}
```

Эта программа должна дать следующий результат:

```text
34.56
-2.08
-2.08
-2.08
-0.05
-0.05
```

Подсказка: хотя поначалу может показаться, что для этого необходимо больше работы, но полезно хранить как целую, так и дробную части числа с одним и тем же знаком (например, обе положительные, если число положительное, и обе отрицательные, если число отрицательное). Это значительно упрощает математику в дальнейшем.

Подсказка: чтобы вывести число, сначала преобразуйте его в double.

4c) Теперь добавьте конструктор, который принимает double. Должна запуститься следующая программа:

```cpp
int main()
{
    // Обработка случаев, когда аргумент представлен напрямую
    FixedPoint2 a{ 0.01 };
    std::cout << a << '\n';
 
    FixedPoint2 b{ -0.01 };
    std::cout << b << '\n';
 
    // Обработка случаев, когда в аргументе есть ошибка округления
    FixedPoint2 c{ 5.01 }; // хранится как 5.0099999 ... поэтому нам нужно округлить его
    std::cout << c << '\n';
 
    FixedPoint2 d{ -5.01 }; // хранится как -5.0099999 ... поэтому нам нужно округлить его
    std::cout << d << '\n';
 
    // Обработка случая, когда дробная часть аргумента округляется до 100
    // (необходимо увеличить целую часть на 1)
    FixedPoint2 e{ 106.9978 }; // должно сохраниться с целой частью 107 и дробной частью 0
    std::cout << e << '\n';
 
 
    return 0;
}
```

Эта программа должна дать следующий результат

```text
0.01
-0.01
5.01
-5.01
107
```

Рекомендация: это будет немного сложно. Разбейте выполнение на три этапа. Во-первых, решите случаи, когда параметр double может быть представлен напрямую (случаи a и b выше). Затем обновите свой код для обработки случаев, когда параметр double имеет ошибку округления (случаи c и d). Наконец, обработайте последний случай, когда дробная часть округляется до 100 (случай e).

4d) Перегрузите operator==, operator>>, operator- (унарный) и operator+ (бинарный).

Должна запуститься следующая программа:

```cpp
void testAddition()
{
    std::cout << std::boolalpha;
    // оба положительные, без переполнения дробной части
    std::cout << (FixedPoint2{ 0.75 } + FixedPoint2{ 1.23 } == FixedPoint2{ 1.98 }) << '\n';
    // оба положительные, с переполнением дробной части
    std::cout << (FixedPoint2{ 0.75 } + FixedPoint2{ 1.50 } == FixedPoint2{ 2.25 }) << '\n';
    // оба отрицательные, без переполнения дробной части
    std::cout << (FixedPoint2{ -0.75 } + FixedPoint2{ -1.23 } == FixedPoint2{ -1.98 }) << '\n';
    // оба отрицательные, с переполнением дробной части
    std::cout << (FixedPoint2{ -0.75 } + FixedPoint2{ -1.50 } == FixedPoint2{ -2.25 }) << '\n';
    // второе отрицательное, без переполнения дробной части
    std::cout << (FixedPoint2{ 0.75 } + FixedPoint2{ -1.23 } == FixedPoint2{ -0.48 }) << '\n';
    // второе отрицательное, возможно переполнение дробной части
    std::cout << (FixedPoint2{ 0.75 } + FixedPoint2{ -1.50 } == FixedPoint2{ -0.75 }) << '\n';
   // первое отрицательное, без переполнения дробной части
    std::cout << (FixedPoint2{ -0.75 } + FixedPoint2{ 1.23 } == FixedPoint2{ 0.48 }) << '\n';
    // первое отрицательное, возможно переполнение дробной части
    std::cout << (FixedPoint2{ -0.75 } + FixedPoint2{ 1.50 } == FixedPoint2{ 0.75 }) << '\n';
}
 
int main()
{
    testAddition();
 
    FixedPoint2 a{ -0.48 };
    std::cout << a << '\n';
 
    std::cout << -a << '\n';
 
    std::cout << "Enter a number: "; // введите 5.678
    std::cin >> a;
    
    std::cout << "You entered: " << a << '\n';
 
    return 0;
}
```

И должен выдаваться следующий вывод:

```text
true
true
true
true
true
true
true
true
-0.48
0.48
Enter a number: 5.678
You entered: 5.68
```

Подсказка: сложите два числа FixedPoint2, используя приведение к double, а затем преобразуйте результаты обратно в FixedPoint2.

Подсказка: для operator>> используйте конструктор double для создания анонимного объекта типа FixedPoint2 и присвойте его параметру функции FixedPoint2.

__Ответ:__

[Ответ](Вопрос_4/Вопрос_4.cpp)
___