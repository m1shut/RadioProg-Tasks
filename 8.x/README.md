# Глава 8 – Преобразование типов и перегрузка функций

___

## Вопрос 1

Какой тип преобразования происходит в каждом из следующих случаев? Допустимые ответы: преобразование не требуется, числовое продвижение, числовое преобразование, не будет компилироваться из-за сужающего преобразования. Предположим, что `int` и `long` равны 4 байтам.

```cpp
int main()
{
    int a{ 5 };     // 1a
    int b{ 'a' };   // 1b
    int c{ 5.4 };   // 1c
    int d{ true };  // 1d
    int e{ static_cast<int>(5.4) }; // 1e
 
    double f { 5.0f }; // 1f
    double g { 5 };    // 1g
 
    // Немного посложнее
    long h{ 5 };     // 1h
 
    float i { f };   // 1i
    float j { 5.0 }; // 1j

}
```

__Ответ:__

1a) Преобразование не требуется

1b) Числовое продвижение

1c) Не будет компилироваться из-за сужающего преобразования

1d) Числовое продвижение

1e) Явное числовое преобразование

1f) Числовое продвижение

1g) Числовое преобразование

1h) Числовое преобразование

1i) Не будет компилироваться из-за сужающего преобразования

1j) Числовое преобразование
___

## Вопрос 2

2a) Обновите следующую программу, используя псевдонимы типов:

```cpp
#include <iostream>
 
namespace Constants
{
    inline constexpr double pi { 3.14159 };
}
 
double convertToRadians(double degrees)
{
    return degrees * Constants::pi / 180;
}
 
int main()
{
    std::cout << "Enter a number of degrees: ";
    double degrees{};
    std::cin >> degrees;
 
    double radians { convertToRadians(degrees) };
    std::cout << degrees << " degrees is " << radians << " radians.\n";
 
    return 0;
}
```

2b) Основываясь на вопросе 2a, объясните, почему следующая инструкция будет или не будет компилироваться:

```cpp
radians = degrees;
```

__Ответ:__

2a) [Решение](Вопрос_2.a/Вопрос_2.a.cpp)

2b) Эта инструкция будет компилироваться, потому что градусы и радианы — числа с плавающей точкой типа `double`.
___

## Вопрос 3

3a) Что выдает эта программа и почему?

```cpp
void print(int x)
{
    std::cout << "int " << x << '\n';
}
 
void print(double x)
{
    std::cout << "double " << x << '\n';
}
 
int main()
{
    short s { 5 };
    print(s);
 
    return 0;
}
```

3b) Почему следующий код не компилируется?

```cpp
void print()
{
    std::cout << "void\n";
}
 
void print(int x=0)
{
    std::cout << "int " << x << '\n';
}
 
void print(double x)
{
    std::cout << "double " << x << '\n';
}
 
int main()
{
    print(5.0f);
    print();
 
    return 0;
}
```

3c) Почему следующий код не компилируется?

```cpp
void print(long x)
{
    std::cout << "long " << x << '\n';
}
 
void print(double x)
{
    std::cout << "double " << x << '\n';
}
 
int main()
{
    print(5);
 
    return 0;
}
```

__Ответ:__

3a) Программа выдаст `int 5`. Компилятор считает числовое продвижение `short` в `int` предпочтительнее чем числовое преобразование `short` в `double`.

3b) В `void print(int x=0)` аргумент `x` не делает функцию уникальной по отношению к `void print()`, так как он имеет значение по умолчанию. Поэтому компилятор не может определить, какую из них вызвать в строке 19.

3c) В аргументе передают `int 5`. Компилятор не может выбрать одно из двух возможных числовых преобразований: `int` в `long` или `int` в `double`
___

## Вопрос 4

Что выдает эта программа и почему?

```cpp
#include <iostream>
 
template <typename T>
int count(T x)
{
    static int c { 0 };
    return ++c;
}
 
int main()
{
    std::cout << count(1);
    std::cout << count(1);
    std::cout << count(2.3);
    std::cout << count<double>(1);
    
    return 0;
}
```

__Ответ:__

Программа выдаст: `1212`

При вызове `count(1)` программа создаст экземпляр функции — `count<int>(int)`. Далее эта функция вызывается второй раз.

С вызовом функции `count(2.3)` программа создаст ещё один экземпляр функции — `count<double>(double)`. Она будет вызвана второй раз с неявным преобразованием `int 1` в `double`.
___

## Вопрос 5

5a) Напишите шаблон функции с именем `add`, который позволяет пользователям складывать 2 значения одного типа. Следующая программа должна запуститься:

```cpp
#include <iostream>

// напишите здесь свой шаблон функции add

int main()
{
        std::cout << add(2, 3) << '\n';
        std::cout << add(1.2, 3.4) << '\n';
 
        return 0;
}
```

и выдать следующий результат:

```text
5
4.6
```

5b) Напишите шаблон функции с именем mult, который позволяет пользователю умножать одно значение любого типа на число int. Следующая программа должна запуститься:

```cpp
#include <iostream>
 
// напишите здесь свой шаблон функции mult
 
int main()
{
	std::cout << mult(2, 3) << '\n';
	std::cout << mult(1.2, 3) << '\n';
 
	return 0;
}
```

и выдать следующий результат:

```text
6
3.6
```

5c) Напишите шаблон функции с именем sub, который позволяет пользователю вычитать два значения разных типов. Следующая программа должна запуститься:

```cpp
#include <iostream>
 
// напишите здесь свой шаблон функции sub
 
int main()
{
	std::cout << sub(3, 2) << '\n';
	std::cout << sub(3.5, 2) << '\n';
	std::cout << sub(4, 1.5) << '\n';
 
	return 0;
}
```

и выдать следующий результат:

```text
1
1.5
2.5
```

__Ответ:__

5a) [Решение](Вопрос_5.a/Вопрос_5.a.cpp)


5b) [Решение](Вопрос_5.b/Вопрос_5.b.cpp)


5c) [Решение](Вопрос_5.c/Вопрос_5.c.cpp)
