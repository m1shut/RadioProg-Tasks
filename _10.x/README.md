# Глава 10 – Массивы, строки, указатели и ссылки

___

## Вопрос 1

Представьте, что вы пишете игру, в которой игрок может держать в руках 3 типа предметов: зелья здоровья (health potion), факелы (torch) и стрелы (arrow). Создайте перечисление для идентификации различных типов элементов и массив `std::array` для хранения количества единиц каждого элемента, который несет игрок (перечислители используются в качестве индексов массива). Игрок должен начать с 2 зельями здоровья, 5 факелами и 10 стрелами. Напишите функцию `countTotalItems()`, которая возвращает общее количество элементов, которые есть у игрока. Заставьте вашу функцию `main()` распечатать выходное значение `countTotalItems()`, а также количество факелов.

__Ответ:__

[ответ](вопрос_1/вопрос_1.cpp)
___

## Вопрос 2

Напишите следующую программу: создайте структуру, содержащую имя студента и его оценку (по шкале от 0 до 100). Спросите пользователя, сколько студентов он хочет ввести. Создайте `std::vector` для хранения данных всех студентов. Затем запросите у пользователя каждое имя и оценку. После того, как пользователь ввел все пары имен и оценок, отсортируйте список по оценкам (сначала самая высокая). Затем выведите все имена и оценки в отсортированном порядке.

Для следующего ввода:

```text
Joe
82
Terry
73
Ralph
4
Alex
94
Mark
88
```

Вывод должен выглядеть так:

```text
Alex got a grade of 94
Mark got a grade of 88
Joe got a grade of 82
Terry got a grade of 73
Ralph got a grade of 4
```

Вы можете предположить, что имена не содержат пробелов и что извлечение входных данных не завершается ошибкой.

__Ответ:__

[ответ](Вопрос_2/Вопрос_2.cpp)
___

## Вопрос 3

Напишите свою собственную функцию для обмена значениями двух целочисленных переменных. Напишите функцию `main()`, чтобы проверить ее.

__Ответ:__

[ответ](Вопрос_3/Вопрос_3.cpp)
___

## Вопрос 4

Напишите функцию для посимвольной печати строки в стиле C. Используйте указатель для перехода по символам строки и печати текущего символа. Остановитесь, когда вы встретите нулевой терминатор. Напишите функцию `main`, которая проверяет эту функцию со строковым литералом `"Hello, world!"`.

Используйте оператор ++, чтобы переместить указатель на следующий символ.

__Ответ:__

[ответ](Вопрос_4/Вопрос_4.cpp)
___

## Вопрос 5

Что не так с каждым из этих фрагментов кода, и как это исправить?

a)

```cpp
int main()
{
  int array[]{ 0, 1, 2, 3 };
 
  for (std::size_t count{ 0 }; count <= std::size(array); ++count)
  {
    std::cout << array[count] << ' ';
  }
 
  std::cout << '\n';
 
  return 0;
}
```

b)

```cpp
int main()
{
  int x{ 5 };
  int y{ 7 };
 
  const int* ptr{ &x };
  std::cout << *ptr << '\n';
  *ptr = 6;
  std::cout << *ptr << '\n';
  ptr = &y;
  std::cout << *ptr << '\n';
 
  return 0;
}
```

c)

```cpp
void printArray(int array[])
{
  for (int element : array)
  {
    std::cout << element << ' ';
  }
}
 
int main()
{
  int array[]{ 9, 7, 5, 3, 1 };
 
  printArray(array);
 
  std::cout << '\n';
 
  return 0;
}
```

d)

```cpp
int* allocateArray(const int length)
{
  int temp[length]{};
  return temp;
}
```

e)

```cpp
int main()
{
  double d{ 5.5 };
  int* ptr{ &d };
  std::cout << ptr << '\n';
 
  return 0;
}
```

__Ответ:__

a) Ошибка на единицу. Цикл `for` выполнится на 1 раз больше, чем нужно. Нужно заменить `<=` на `<`

b) `ptr` — константный указатель на `int`, ему нельзя присвоить значение `6` или `y`. Это можно исправить сделав `ptr` неконстантным

c) Функция `printArray` не знает размер массива в стиле C. По этому цикл `for` будет работать некорректно. Можно либо добавить аргумент размера массива, либо использовать `std::array` для `array`

d) `length` — константа времени выполнения, когда для фиксированного массива `temp` нужна константа времени компиляции. Также, в конце функции `temp` уничтожиться, а возвращённое значение будет указывать на область памяти с неизвестным содержанием. Для `temp` стоит использовать `std::vector`

e) Указателю типа `int` присваивается адрес на переменную `double`. `ptr` должен быть типа double
___

## Вопрос 6

Представим, что мы пишем карточную игру.

a) В колоде 52 уникальных карты (13 рангов карт по 4 масти). Создайте перечисления для рангов карт (2, 3, 4, 5, 6, 7, 8, 9, 10, валет (Jack), дама (Queen), король (King), туз (Ace)) и мастей (трефы (clubs), бубны (diamonds), червы (hearts), пики (spades)). Эти перечислители не будут использоваться для индексации массивов.

b) Каждая карта будет представлена структурой с именем `Card`, которая содержит ранг (rank) и масть (suit). Создайте структуру.

c) Создайте функцию `printCard()`, которая принимает ссылку на `const Card` в качестве параметра и печатает ранг и масть карты в виде двухбуквенного кода (например, пиковый валет будет печататься как JS (от jack spades)).

d) В колоде 52 карты. Создайте массив (используя `std::array`) для представления колоды карт и инициализируйте его по одной карте каждого типа. Сделайте это в функции с именем `createDeck` и вызовите `createDeck` из `main`. `createDeck` должен вернуть колоду в `main`.

Подсказка: используйте `static_cast`, если вам нужно преобразовать целочисленный тип `int` в перечислимый тип.

e) Напишите функцию с именем `printDeck()`, которая принимает колоду в качестве параметра константной ссылки и печатает карты в колоде. Используйте цикл `for` на основе диапазона. Когда вы вызовете `printDeck` с колодой, которую вы создали в предыдущей задаче, вывод должен быть таким:

```text
2C 3C 4C 5C 6C 7C 8C 9C TC JC QC KC AC 2D 3D 4D 5D 6D 7D 8D 9D TD JD QD KD AD 2H 3H 4H 5H 6H 7H 8H 9H TH JH QH KH AH 2S 3S 4S 5S 6S 7S 8S 9S TS JS QS KS AS
```

Если вы использовали другие символы, это нормально.

f) Напишите функцию с именем `shuffleDeck` для перетасовки колоды карт с помощью `std::shuffle`. Обновите свою функцию `main`, чтобы перетасовать колоду и распечатать ее уже перетасованной.

Напоминание: инициализируйте генератор случайных чисел только один раз.

g) Напишите функцию с именем `getCardValue()`, которая возвращает значение карты (например, 2 стоит 2, десятка, валет, дама или король стоят 10. Предположим, что туз стоит 11).

__Ответ:__

[ответ](Вопрос_6/Вопрос_6.cpp)
___

## Вопрос 7

а) Хорошо, время бросить вызов! Напишем упрощенную версию блэкджека. Если вы еще не знакомы с блэкджеком, в Википедии есть статья с кратким описанием.

Вот правила нашей версии блэкджека:

* для начала дилер получает одну карту (в реальной жизни дилер получает две, но одна закрыта, поэтому на данном этапе это не имеет значения);
* для начала игрок получает две карты;
* игрок ходит первым.
* игрок может многократно сказать «еще» (hit) или сказать «достаточно» (stand);
* если игрок говорит «достаточно», его ход заканчивается, и его счет рассчитывается на основе карт, которые ему были розданы;
* если игрок говорит «еще», он получает еще одну карту, и значение этой карты добавляется к его общему счету;
* туз обычно засчитывается как 1 или 11 (в зависимости от того, что лучше для общего счета); для простоты мы будем считать здесь 11;
* если у игрока больше 21 очка, он сразу же проигрывает;
* дилер ходит после игрока;
* дилер несколько раз тянет карты, пока не наберет 17 или более очков, после чего он останавливается;
* если у дилера больше 21 очков, он проигрывает, и игрок немедленно выигрывает;
* в противном случае, если у игрока больше очков, чем у дилера, игрок выигрывает. В противном случае игрок проигрывает (для простоты мы будем рассматривать ничью как выигрыш дилера);
* в нашей упрощенной версии блэкджека мы не будем отслеживать, какие именно карты были сданы игроку и дилеру. Мы будем отслеживать только сумму значений карт, которые были розданы игроку и дилеру. Это упрощает работу.

Начните с кода, который вы написали в вопросе 6. Создайте функцию с именем `playBlackjack()`. Эта функция должна:

* принимать в качестве параметра перетасованную колоду карт;
* реализовывать партию блэкджека, как описано выше;
* возвращать `true`, если выиграл игрок, и `false`, если он проиграл.
Также напишите функцию `main()` для одиночной игры в блэкджек.

b) Дополнительное задание: время критического мышления: опишите, как вы можете изменить приведенную выше программу, чтобы справиться со случаем, когда тузы могут быть равны 1 или 11.
Важно отметить, что мы отслеживаем только сумму карт, а не то, какие именно карты есть у пользователя.

c) В реальном блэкджеке, если у игрока и дилера одинаковый счет (и у игрока нет перебора), результатом считается ничья, и ни один из них не выигрывает. Опишите, как бы вы изменили приведенную выше программу, чтобы учесть это.

__Ответ:__

a) [ответ](вопрос_7/вопрос_7.cpp)

b) Добавить условие в `giveNextCard`. Если из колоды достаётся туз и количество очков с ним (считая его как 11 очков) больше 21, добавить туз как одно очко. Иначе добавить туз как 11 очков.

c) Добавить класс перечисление результата игры: победа игрока, проигрыш игрока и ничья. Изменить тип функции `playBlackjack` на перечисление. Следовательно, заменить возвращаемые логические значения на значение перечисления. Добавить в сравнение очков исход ничьи
